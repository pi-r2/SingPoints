

# This file was *autogenerated* from the file exp_sing.sage
from sage.all_cmdline import *   # import sage library

_sage_const_251 = Integer(251); _sage_const_4 = Integer(4); _sage_const_10 = Integer(10); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0)## This file runs some experiments on small UOV systems to 
## demonstrate the properties of the singular locus of a UOV system.
import os 
load("UOV.sage")
load("tools.sage")

q = _sage_const_251 

# Generate systems of equations 

for m in range(_sage_const_4 , _sage_const_10 ) : #Number of equations in the public key
    for n in range(_sage_const_2 *m, _sage_const_3 *m+_sage_const_1 ) : #Number of variables
        d = _sage_const_3 *m-n-_sage_const_2  #Dimension of the singular locus - 1
        if d < _sage_const_0  :
            continue
        (A,F), G = KeyGen(q, m, n-m) #Generate a UOV key pair
        R = PolynomialRing(GF(q), ['y'+str(i) for i in range(m-_sage_const_1 )] + ['x'+str(i) for i in range(n-_sage_const_1 )], m+n-_sage_const_2 )
        X = vector([_sage_const_1 ] + list(R.gens())[m-_sage_const_1 :]) #Deshomogeneize the system
        Y = vector([_sage_const_1 ] + list(R.gens())[:m-_sage_const_1 ]) #Obtain a one-to-one correspondance between singular points and y vectors
        J = matrix([X*g for g in G]) #Jacobian matrix
        sys = list(Y*J) + [X*g*X for g in G]
        rand_eqs = [] #Intersect with random hyperplanes to reach dimension 0.
        for _ in range(d) :
            rand_eqs.append(
            (matrix(GF(q), _sage_const_1 , n, [GF(q).random_element() for _ in range(n)])*X)[_sage_const_0 ]
            )
        ToMSolve(rand_eqs + sys, "/tmp/bi"+str(m)+"_"+str(n)+".ms") #Put the system in msolve input format

# Use msolve to solve the systems.
# The larger systems will be more expensive to solve.
# Set m below to a value of your choice in range(4,10).
m= _sage_const_4 
# 

for n in range(_sage_const_2 *m, _sage_const_3 *m+_sage_const_1 ) :
    d = _sage_const_3 *m-n-_sage_const_2 
    if d < _sage_const_0  :
        continue
    print("(m,n)", m, n)
    R = PolynomialRing(GF(q), ['y'+str(i) for i in range(m-_sage_const_1 )] + ['x'+str(i) for i in range(n-_sage_const_1 )], m+n-_sage_const_2 )
    X = vector([_sage_const_1 ] + list(R.gens())[m-_sage_const_1 :])
    Y = vector([_sage_const_1 ] + list(R.gens())[:m-_sage_const_1 ])
    file="/tmp/bi"+str(m)+"_"+str(n)
    
    #Get the public key that defined the equations (deshomogeneized by x0 = 1)

    pub = FromMsolve(file+".ms", R)[-m:]

    #Solve the bihomogeneous system
    os.system("./msolve -v2 -g2 -f "+file+".ms -o "+file+".o > "+file+".log")
    
    #Study the result
    gb = FromMsolve(file+".o", R)
    print("The first equations of the Gr√∂bner basis are linear:")
    for i in range(n-m) :
        print(gb[i])
    M = [[_sage_const_0 ] + [gb[i].coefficient(X[j+_sage_const_1 ]) for j in range(n-_sage_const_1 )]
                for i in range(n-m+d)]
    M = matrix(GF(q), M)
    for i in range(n-m+d) :
        M[i,_sage_const_0 ] = gb[i]([_sage_const_0  for _ in range(n+m-_sage_const_2 )])
    V = M.right_kernel().random_element()
    while V[_sage_const_0 ] == _sage_const_0 :
        V = M.right_kernel().random_element()
    V = V[_sage_const_0 ]**(-_sage_const_1 )*V #Normalize to the same value used to deshomogeneize.
    evals = [GF(q).random_element() for _ in range(m-_sage_const_1 )]
    print('Evaluation of the public key on a random vector from the intersection of the kernels of the hyperplanes:')
    for g in pub :
        print(g(evals+list(V[_sage_const_1 :])))  

    hgb = [g.lt() for g in gb]
    I = Ideal(hgb)
    h = I.hilbert_series()
    deg = h.numerator()(_sage_const_1 ) #equal to 0 if the singular locus is of dimension d
    dim = h.denominator().degree()
    print("The degree of the variety is",deg)
    print(' ')

